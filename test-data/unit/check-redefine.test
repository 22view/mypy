-- Test cases for the redefinition of variable with a different type.


-- Redefine local variable
-- -----------------------


[case testRedefineLocalWithDifferentType]
def f() -> None:
    x = 0
    reveal_type(x) # E: Revealed type is 'builtins.int'
    x = ''
    reveal_type(x) # E: Revealed type is 'builtins.str'

[case testCannotConditionallyRedefineLocalWithDifferentType]
def f() -> None:
    y = 0
    reveal_type(y) # E: Revealed type is 'builtins.int'
    if int():
        y = ''  \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        reveal_type(y)  # E: Revealed type is 'builtins.int'
    reveal_type(y) # E: Revealed type is 'builtins.int'

[case testRedefineFunctionArg]
def f(x: int) -> None:
    x = ''
    reveal_type(x) # E: Revealed type is 'builtins.str'
def g(x: int) -> None:
    if int():
        x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        reveal_type(x) # E: Revealed type is 'builtins.int'

[case testCannotRedefineAnnotationOnly]
def f() -> None:
    x: int
    x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int'
def g() -> None:
    x: int # This syntax prevents redefinition through assignment
    x = 1
    x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testRedefineLocalUsingOldValue]
from typing import TypeVar, Union

T = TypeVar('T')

def f(x: int) -> None:
    x = g(x)
    reveal_type(x)  # E: Revealed type is 'Union[builtins.int*, builtins.str]'
    y = 1
    y = g(y)
    reveal_type(y)  # E: Revealed type is 'Union[builtins.int*, builtins.str]'

def g(x: T) -> Union[T, str]: pass

[case testRedefineLocalForLoopIndexVariable]
from typing import Iterable
def f(a: Iterable[int], b: Iterable[str]) -> None:
    for x in a:
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int*'
    for x in b:
        x = 1 \
        # E: Incompatible types in assignment (expression has type "int", variable has type "str")
    reveal_type(x) # E: Revealed type is 'builtins.str*'

def g(a: Iterable[int]) -> None:
    for x in a: pass
    x = ''

def h(a: Iterable[int]) -> None:
    x = ''
    for x in a: pass

[case testCannotRedefineLocalWithinTry]
def f() -> None:
    try:
        x = 0
        g()  # Might raise an exception
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    except:
        pass
    reveal_type(x) # E: Revealed type is 'builtins.int'
    y = 0
    y = ''

def g(): pass

[case testCannotRedefineLocalWithinWith]
def f() -> None:
    with g():
        x = 0
        g()  # Might raise an exception
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int'
    y = 0
    y = ''

def g(): pass

[case testCannotRedefineAcrossNestedFunction]
def f() -> None:
    x = 0
    def g() -> None:
        x
    g()
    x = '' \
    # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    g()
    y = 0
    y = ''

[case testCannotRedefineAcrossNestedDecoratedFunction]
def dec(f): return f

def f() -> None:
    x = 0
    @dec
    def g() -> None:
        x
    g()
    x = '' \
    # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    g()
    y = 0
    y = ''

[case testCannotRedefineAcrossNestedOverloadedFunction]
from typing import overload

def f() -> None:
    x = 0
    @overload
    def g() -> None: pass
    @overload
    def g(x: int) -> None: pass
    def g(x=0):
        pass
    g()
    x = '' \
    # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    g()
    y = 0
    y = ''

[case testRedefineLocalInMultipleAssignment]
def f() -> None:
    x, x = 1, ''
    reveal_type(x) # E: Revealed type is 'builtins.str'
    x = object()
    reveal_type(x) # E: Revealed type is 'builtins.object'

def g() -> None:
    x = 1
    if 1:
        x, x = '', 1 \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testRedefineUnderscore]
def f() -> None:
    _, _ = 1, ''
    if 1:
        _, _ = '', 1
        reveal_type(_) # E: Revealed type is 'Any'

[case testRedefineWithBreakAndContinue]
def f() -> None:
    y = 0
    while int():
        z = 0
        z = ''
        x = 0
        if int():
            break
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int'
    y = ''

def g() -> None:
    y = 0
    for a in h():
        z = 0
        z = ''
        x = 0
        if int():
            continue
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int'
    y = ''

def h(): pass

[case testRedefineLocalAndNestedLoops]
def f() -> None:
    z = 0
    while int():
        x = 0
        while int():
            if 1:
                y = 1
                if int():
                    break
                y = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        x = ''
    z = ''

[case testCannotRedefineVarAsFunction]
def f() -> None:
    def x(): pass
    x = 1 # E: Name 'x' already defined on line 2
    reveal_type(x) # E: Revealed type is 'def () -> Any'
    y = 1
    def y(): pass # E: Name 'y' already defined on line 5

[case testCannotRedefineVarAsClass]
def f() -> None:
    class x: pass
    x = 1 # E: Name 'x' already defined (possibly by an import)
    y = 1
    class y: pass # E: Name 'y' already defined on line 4

[case testCannotRedefineVarAsTypeVar]
from typing import TypeVar
def f() -> None:
    x = TypeVar('x')
    x = 1 # E: Name 'x' already defined on line 3
    def g(a: x) -> x: pass
    reveal_type(g(1)) # E: Revealed type is 'builtins.int*'
    y = 1
    # This is arguably inconsistent -- we accept this since it looks like an assignment.
    y = TypeVar('y')
    def h(a: y) -> y: return a
    reveal_type(h('')) # E: Revealed type is 'builtins.str*'

[case testCannotRedefineVarAsModule]
def f() -> None:
    import typing as m
    m = 1 # E: Name 'm' already defined (by an import)
    n = 1
    import typing as n # E: Name 'n' already defined on line 4
[builtins fixtures/module.pyi]
