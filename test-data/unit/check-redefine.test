-- Test cases for the redefinition of variable with a different type.


-- Redefine local variable
-- -----------------------


[case testRedefineLocalWithDifferentType]
def f() -> None:
    x = 0
    reveal_type(x) # E: Revealed type is 'builtins.int'
    x = ''
    reveal_type(x) # E: Revealed type is 'builtins.str'

[case testCannotConditionallyRedefineLocalWithDifferentType]
def f() -> None:
    y = 0
    reveal_type(y) # E: Revealed type is 'builtins.int'
    if int():
        y = ''  \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        reveal_type(y)  # E: Revealed type is 'builtins.int'
    reveal_type(y) # E: Revealed type is 'builtins.int'

[case testRedefineFunctionArg]
def f(x: int) -> None:
    x = ''
    reveal_type(x) # E: Revealed type is 'builtins.str'
def g(x: int) -> None:
    if int():
        x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        reveal_type(x) # E: Revealed type is 'builtins.int'

[case testRedefineAnnotationOnly]
def f() -> None:
    x: int
    x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int'
def g() -> None:
    x: int
    x = 1
    reveal_type(x) # E: Revealed type is 'builtins.int'
    x = ''
    reveal_type(x) # E: Revealed type is 'builtins.str'

[case testRedefineLocalUsingOldValue]
from typing import TypeVar, Union

T = TypeVar('T')

def f(x: int) -> None:
    x = g(x)
    reveal_type(x)  # E: Revealed type is 'Union[builtins.int*, builtins.str]'
    y = 1
    y = g(y)
    reveal_type(y)  # E: Revealed type is 'Union[builtins.int*, builtins.str]'

def g(x: T) -> Union[T, str]: pass

[case testRedefineLocalForLoopIndexVariable]
from typing import Iterable
def f(a: Iterable[int], b: Iterable[str]) -> None:
    for x in a:
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int*'
    for x in b:
        x = 1 \
        # E: Incompatible types in assignment (expression has type "int", variable has type "str")
    reveal_type(x) # E: Revealed type is 'builtins.str*'

def g(a: Iterable[int]) -> None:
    for x in a: pass
    x = ''

def h(a: Iterable[int]) -> None:
    x = ''
    for x in a: pass

[case testCannotRedefineLocalWithinTry]
def f() -> None:
    try:
        x = 0
        g()  # Might raise an exception
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    except:
        pass
    reveal_type(x) # E: Revealed type is 'builtins.int'
    y = 0
    y = ''

def g(): pass

[case testCannotRedefineLocalWithinWith]
def f() -> None:
    with g():
        x = 0
        g()  # Might raise an exception
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int'
    y = 0
    y = ''

def g(): pass

[case testCannotRedefineAcrossNestedFunction]
def f() -> None:
    x = 0
    def g() -> None:
        x
    g()
    x = '' \
    # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    g()
    y = 0
    y = ''

[case testCannotRedefineAcrossNestedDecoratedFunction]
def dec(f): return f

def f() -> None:
    x = 0
    @dec
    def g() -> None:
        x
    g()
    x = '' \
    # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    g()
    y = 0
    y = ''

[case testCannotRedefineAcrossNestedOverloadedFunction]
from typing import overload

def f() -> None:
    x = 0
    @overload
    def g() -> None: pass
    @overload
    def g(x: int) -> None: pass
    def g(x=0):
        pass
    g()
    x = '' \
    # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    g()
    y = 0
    y = ''

[case testRedefineLocalInMultipleAssignment]
def f() -> None:
    x, x = 1, ''
    reveal_type(x) # E: Revealed type is 'builtins.str'
    x = object()
    reveal_type(x) # E: Revealed type is 'builtins.object'

def g() -> None:
    x = 1
    if 1:
        x, x = '', 1 \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testRedefineUnderscore]
def f() -> None:
    _, _ = 1, ''
    if 1:
        _, _ = '', 1
        reveal_type(_) # E: Revealed type is 'Any'

[case testRedefineWithBreakAndContinue]
def f() -> None:
    y = 0
    while int():
        z = 0
        z = ''
        x = 0
        if int():
            break
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int'
    y = ''

def g() -> None:
    y = 0
    for a in h():
        z = 0
        z = ''
        x = 0
        if int():
            continue
        x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x) # E: Revealed type is 'builtins.int'
    y = ''

def h(): pass

[case testRedefineLocalAndNestedLoops]
def f() -> None:
    z = 0
    while int():
        x = 0
        while int():
            if 1:
                y = 1
                if int():
                    break
                y = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        x = ''
    z = ''

[case testCannotRedefineVarAsFunction]
def f() -> None:
    def x(): pass
    x = 1 # E: Incompatible types in assignment (expression has type "int", variable has type "Callable[[], Any]")
    reveal_type(x) # E: Revealed type is 'def () -> Any'
    y = 1
    def y(): pass # E: Name 'y' already defined on line 5

[case testCannotRedefineVarAsClass]
def f() -> None:
    class x: pass
    x = 1 # E: Cannot assign to a type \
          # E: Incompatible types in assignment (expression has type "int", variable has type "Type[x]")
    y = 1
    class y: pass # E: Name 'y' already defined on line 4

[case testRedefineVarAsTypeVar]
from typing import TypeVar
def f() -> None:
    # Since these look like assignments, they can be redefined.
    x = TypeVar('x')
    x = 1
    reveal_type(x) # E: Revealed type is 'builtins.int'
    y = 1
    y = TypeVar('y')
    # TODO: This should either work or we should give an error earlier.
    def h(a: y) -> y: return a # E: Invalid type "y"

[case testCannotRedefineVarAsModule]
def f() -> None:
    import typing as m
    m = 1 # E: Incompatible types in assignment (expression has type "int", variable has type Module)
    n = 1
    import typing as n # E: Name 'n' already defined on line 4
[builtins fixtures/module.pyi]

[case testRedefineLocalWithTypeAnnotation]
def f() -> None:
    x = 1
    x = ''  # type: object
    reveal_type(x)  # E: Revealed type is 'builtins.object'
def g() -> None:
    x = 1
    x: object = ''
    reveal_type(x)  # E: Revealed type is 'builtins.object'
def h() -> None:
    x: int
    x = 1
    x: object
    x: object = '' # E: Name 'x' already defined on line 12
def farg(x: int) -> None:
    x: str = ''

[case testRedefineLocalWithTypeAnnotationSpecialCases]
def f() -> None:
    x: object
    x = 1
    if int():
        x = ''
    reveal_type(x) # E: Revealed type is 'builtins.object'
    x = ''
    reveal_type(x) # E: Revealed type is 'builtins.str'
    if int():
        x = 2 \
        # E: Incompatible types in assignment (expression has type "int", variable has type "str")


-- Redefine global variable
-- ------------------------


[case testRedefineGlobalWithDifferentType]
import m
reveal_type(m.x)
[file m.py]
x = 0
reveal_type(x)
x = object()
reveal_type(x)
x = ''
reveal_type(x)
[out]
tmp/m.py:2: error: Revealed type is 'builtins.int'
tmp/m.py:4: error: Revealed type is 'builtins.object'
tmp/m.py:6: error: Revealed type is 'builtins.str'
main:2: error: Revealed type is 'builtins.str'

[case testRedefineGlobalForIndex]
import m
reveal_type(m.x)
[file m.py]
from typing import Iterable
def f(): pass
it1: Iterable[int] = f()
it2: Iterable[str] = f()
for x in it1:
    reveal_type(x)
for x in it2:
    reveal_type(x)
reveal_type(x)
[out]
tmp/m.py:6: error: Revealed type is 'builtins.int*'
tmp/m.py:8: error: Revealed type is 'builtins.str*'
tmp/m.py:9: error: Revealed type is 'builtins.str*'
main:2: error: Revealed type is 'builtins.str*'

[case testRedefineGlobalBasedOnPreviousValues]
from typing import TypeVar, Iterable
T = TypeVar('T')
def f(x: T) -> Iterable[T]: pass
a = 0
a = f(a)
reveal_type(a) # E: Revealed type is 'typing.Iterable[builtins.int*]'

[case testRedefineGlobalWithSeparateDeclaration]
x = ''
reveal_type(x) # E: Revealed type is 'builtins.str'
x: int
x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
x: object
x = 1
reveal_type(x) # E: Revealed type is 'builtins.int'
if int():
    x = object()
