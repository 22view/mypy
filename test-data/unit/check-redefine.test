-- Redefinition of variable with a different type
-- ----------------------------------------------


[case testRedefineLocalWithDifferentType]
def f() -> None:
    x = 0
    reveal_type(x)  # E: Revealed type is 'builtins.int'
    x = ''
    reveal_type(x)  # E: Revealed type is 'builtins.str'

[case testCannotConditionallyRedefineLocalWithDifferentType]
def f() -> None:
    y = 0
    reveal_type(y)  # E: Revealed type is 'builtins.int'
    if int():
        y = ''  \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        reveal_type(y)  # E: Revealed type is 'builtins.int'
    reveal_type(y)  # E: Revealed type is 'builtins.int'

[case testRedefineFunctionArg]
def f(x: int) -> None:
    x = ''
    reveal_type(x) # E: Revealed type is 'builtins.str'
def g(x: int) -> None:
    if int():
        x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        reveal_type(x) # E: Revealed type is 'builtins.int'

[case testCannotRedefineAnnotationOnly]
def f() -> None:
    x: int
    x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    reveal_type(x)  # E: Revealed type is 'builtins.int'
def g() -> None:
    x: int  # This syntax prevents redefinition through assignment
    x = 1
    x = '' \
        # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testRedefineLocalUsingOldValue]
from typing import TypeVar, Union

T = TypeVar('T')

def f(x: int) -> None:
    x = g(x)
    reveal_type(x)  # E: Revealed type is 'Union[builtins.int*, builtins.str]'
    y = 1
    y = g(y)
    reveal_type(y)  # E: Revealed type is 'Union[builtins.int*, builtins.str]'

def g(x: T) -> Union[T, str]: pass
